{
  "hash": "003dd32783256728982a531e853ad6da",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Singular value decomposition (SVD)\njupyter: python3\n---\n\n\n\n\n\n\n\n\n\nThis section focuses on using using the SVD to find a linear subspace of lower dimension in which to project the data. The objective is to show that dimensionality reduction works well in linear subspaces when the underlying structure is linear but quickly shows limitation for non-linear structures.\n\n### Application to affine function\n\nThe first application is an affine functions in R2\n\n#### Function definition and SVD computation\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nn_sample = 100                                                                              # Choose number of samples\nx = np.linspace(0,10,n_sample)                                                              # create vector x\n\n# Affine parameters\na = 1.5                                                                                     # Slope\nb=0                                                                                         # y-axis origin\n\n# Affine function\ny = a*x+b                                                                                   # Affine function\nX = np.stack((x,y))                                                                         # Create numpy array\n\n# Noise\nn_coef = 1                                                                                  # Noise magnitude\nX += + n_coef*np.random.rand(*X.shape)                                                      # Noisy data\n\n# SVD\nU,S,V = np.linalg.svd(X)                                                                   # SV Decomposition\n```\n:::\n\n\n#### Plots\n\nPlot the principal directions from onto the data set\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# plots\n# Origin point\norigin = np.array([[0, 0], [0, 0]]) \nU_scaled = -5*U\nplt.figure(figsize=(6, 6))\n# plt.quiver(*origin, U_scaled[:, 0], U_scaled[:, 1], angles='xy', scale_units='xy', scale=1, color=['r', 'b'])\nplt.quiver(*origin, U_scaled[0, 0], U_scaled[0, 1], angles='xy', scale_units='xy', scale=1, color=['r'], label=r'$\\nu_1$')\nplt.quiver(*origin, U_scaled[1, 0], U_scaled[1, 1], angles='xy', scale_units='xy', scale=1, color=['b'], label=r'$\\nu_2$')\nplt.legend()\nplt.gca().set_aspect('equal')\nplt.ylim(-4, 15)\nplt.xlim(-4, 15)\nplt.xlabel(r\"$x$\")\nplt.ylabel(r\"$y$\")\nplt.plot(X[0,:],X[1,:],'+')\nplt.title(\"Principal component base and data points\")\nplt.show()\nplt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](kPCA_v_SVD_files/figure-pdf/cell-4-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nAnd in the latent space\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# in the latent space\n\nX_tilde = np.transpose(U)@X\nplt.plot(X_tilde[0,:],X_tilde[1,:],\"-o\")\nplt.gca().set_aspect('equal', adjustable='box')\nplt.xlabel(r\"$\\nu_1$\")\nplt.ylabel(r\"$\\nu_2$\")\nplt.show()\nplt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](kPCA_v_SVD_files/figure-pdf/cell-5-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nWe can see that the initial 2D data lie in a 1D space and that the first principal direction $\\nu_1$ is sufficient to describe the data set.\n\n### Application to non-linear function\n\nTo show the limitation of the SVD to find non-linear manifold, a sin function is now studied in a similar manner.\n\n#### Function definition and SVD computation\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# In 1D for an sin function\n\n\nn_sample = 100                                                                              # Choose number of samples\n# x = np.linspace(0,np.pi/4,n_sample)\nx = np.linspace(0,6,n_sample)                                                               # create vector x\n\n# Affine parameters\na = 1.5                                                                                     # Slope\nb=0                                                                                         # y-axis origin\n\n# Affine function\ny = np.sin(x)                                                                               # Sin function\nX = np.stack((x,y))                                                                         # Create numpy array\n\n# Noise\nn_coef = 0.1                                                                                  # Noise magnitude\nX += + n_coef*np.random.rand(*X.shape)                                                      # Noisy data\n\n# SVD\nU,S,V = np.linalg.svd(X)                                                                   # SV Decomposition\n\n```\n:::\n\n\n#### Plots\n\nPlot the principal directions from onto the data set\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# plots\n\n\n# Origin point\norigin = np.array([[0, 0], [0, 0]]) \nU_scaled = -5*U\nplt.figure(figsize=(6, 6))\n# plt.quiver(*origin, U_scaled[:, 0], U_scaled[:, 1], angles='xy', scale_units='xy', scale=1, color=['r', 'b'])\nplt.quiver(*origin, U_scaled[0, 0], U_scaled[0, 1], angles='xy', scale_units='xy', scale=1, color=['r'], label=r'$\\nu_1$')\nplt.quiver(*origin, U_scaled[1, 0], U_scaled[1, 1], angles='xy', scale_units='xy', scale=1, color=['b'], label=r'$\\nu_2$')\nplt.legend()\nplt.gca().set_aspect('equal')\n# plt.ylim(-4, 15)\n# plt.xlim(-4, 15)\nplt.xlabel(r\"$x$\")\nplt.ylabel(r\"$y$\")\nplt.plot(X[0,:],X[1,:],'+')\n\nplt.title(\"Principal component base and data points - sin\")\nplt.show()\nplt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](kPCA_v_SVD_files/figure-pdf/cell-7-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nAnd in the latent space\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# in the latent space\n\nX_tilde = np.transpose(U)@X\nplt.plot(X_tilde[0,:],X_tilde[1,:],\"-o\")\nplt.gca().set_aspect('equal', adjustable='box')\nplt.xlabel(r\"$\\nu_1$\")\nplt.ylabel(r\"$\\nu_2$\")\nplt.show()\nplt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](kPCA_v_SVD_files/figure-pdf/cell-8-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nThe SVD does not exhibit a lower dimension space in which the data can be represented. Both principal directions are required to represent the non-linear data set.\n\n## kernel Principal Component Analysis (kPCA)\n\nThis section focuses on using using the kPCA to find a non-linear manifold of lower dimension in which to project the data. The objective is to show that dimensionality reduction works well in non-linear cases where the SVD failed.\n\n### Application to sin function\n\nThe first application is an sin functions in R3\n\n#### Function definition and kPCA computation\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nx = np.linspace(0,4*np.pi,1500)\ny = np.sin(x)                                                                   # Sin function\nn_coef = 0                                                                      # Noise level\nz = np.random.randn(*x.shape)        \nX = np.stack((x,y,z))                                                           # Create 3D dataset\nX += + n_coef*np.random.rand(*X.shape)                                          # Add noise\n```\n:::\n\n\nPCA conventions are transposed compared to SVD\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nY = np.transpose(X)\n```\n:::\n\n\n##### kPCA parameters\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nn_components = 2                                                                 # Number of component of the kpca\nsigma =100                                                                       # sigma for Gaussian kernel\n```\n:::\n\n\n##### Compute the (Gaussian) kernel\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nd_2 = np.sum(Y**2, axis=1).reshape(-1, 1) + np.sum(Y**2, axis=1) - 2 * np.dot(Y, Y.T)\nK = np.exp(-d_2 / (2 * sigma**2))\n```\n:::\n\n\n##### Center the kernel matrix\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nn = K.shape[0]\none_n = np.ones((n, n)) / n\nK_centered = K - one_n @ K - K @ one_n + one_n @ K @ one_n\n```\n:::\n\n\nSVD of the centered kernel\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nU, S, V = np.linalg.svd(K_centered)\n```\n:::\n\n\nTruncation and projection\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nU_k = U[:, :n_components]  # first eigenvectors\nS_k = np.diag(S[:n_components])  # first singular values\n# Project the centered kernel matrix onto the first eigenvectors\nY_kpca = U_k @ S_k  \n```\n:::\n\n\n### Plots\n\nIn the physical space\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ncolors = plt.cm.viridis(np.linspace(0, 1, len(X[0,:])))                                        # Generate a color gradient\n\n# Extract each axis from X\nx_points = X[0, :]\ny_points = X[1, :]\nz_points = X[2, :]\n\n# Plot the scatter in 3D\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nscatter = ax.scatter(x_points, y_points, z_points, c=colors, cmap='plasma', marker='o', s=50)\nax.set_xlabel(r'$ x$')\nax.set_ylabel(r'$ y$')\nax.set_zlabel(r'$ z$')\nplt.title('physical space')\nplt.colorbar(scatter, ax=ax)\nplt.show()\nplt.close()\n\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/vt/tk0pvn6x7dj443pvlvkxzcj00000gn/T/ipykernel_27021/221865655.py:11: UserWarning:\n\nNo data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](kPCA_v_SVD_files/figure-pdf/cell-16-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\nIn the latent space\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nplt.scatter(Y_kpca[:,0], Y_kpca[:,1], color=colors, s=100)                                     # s=100 for larger points\nplt.xlabel(r\"$\\nu_1$\")\nplt.ylabel(r\"$\\nu_2$\")\nplt.title('latent space')\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](kPCA_v_SVD_files/figure-pdf/cell-17-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nimport plotly.graph_objects as go\n\n# Sample data (replace this with your actual data)\n# X = np.random.rand(3, 100)  # Example data\ncolors[:, :3]\n\n# Extract each axis from X\nx_points = X[0, :]\ny_points = X[1, :]\nz_points = X[2, :]\n\n# Create the 3D scatter plot\nfig = go.Figure(data=[go.Scatter3d(\n    x=x_points,\n    y=y_points,\n    z=z_points,\n    mode='markers',\n    marker=dict(\n        size=5,  # Size of the markers\n        color=colors[:,2],  # Color of the markers\n        colorscale='viridis',  # Color scale\n        showscale=True,  # Show color scale\n    )\n)])\n\n# Set axes labels and title\nfig.update_layout(\n    scene=dict(\n        xaxis_title='x',\n        yaxis_title='y',\n        zaxis_title='z',\n    ),\n    title='Physical Space'\n)\n\n# Show the plot\nfig.show()\n```\n\n::: {.cell-output .cell-output-display}\n```\nUnable to display output for mime type(s): text/html\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\nUnable to display output for mime type(s): text/html\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ncolors\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\narray([[0.267004, 0.004874, 0.329415, 1.      ],\n       [0.267004, 0.004874, 0.329415, 1.      ],\n       [0.267004, 0.004874, 0.329415, 1.      ],\n       ...,\n       [0.993248, 0.906157, 0.143936, 1.      ],\n       [0.993248, 0.906157, 0.143936, 1.      ],\n       [0.993248, 0.906157, 0.143936, 1.      ]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ncolors.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n(1500, 4)\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nnp.random.rand(100).shape\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\n(100,)\n```\n:::\n:::\n\n\n",
    "supporting": [
      "kPCA_v_SVD_files/figure-pdf"
    ],
    "filters": []
  }
}